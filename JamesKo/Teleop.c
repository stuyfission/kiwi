#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     Q1,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Q2,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Q3,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Q4,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//i shaved off 60 lines of this code to make it more compact :)

#include "JoystickDriver.c"

int nullRad = 50;
int x1 = 0; int y1 = 0; int x2 = 0;
bool preventsConflict = true;

int scale(int scaleThis) {
	return ((scaleThis - nullRad) * (100/(128 - nullRad)));
}

void move(char direction) {
	int a; int b;
	switch (direction) {
		case 'a': a = 0; b = 1; break;
		case 'n': a = 1; b = 1; break;
		case 'w': a = -1; b = -1; break;
		case 'e': a = -1; b = 1; break;
		case 's': a = 1; b = -1; break;
		case 'z': a = 0; b = -1; break;
	}
	switch (a) {
		case 1: //vertical
			motor[Q1] = b * scale(y1); motor[Q2] = -b * scale(y1);
			motor[Q3] = b * scale(y1); motor[Q4] = -b * scale(y1);
			break;
		case -1: //horizontal
      motor[Q1] = -b * scale(x1); motor[Q2] = -b * scale(x1);
      motor[Q3] = b * scale(x1); motor[Q4] = b * scale(x1);
     case 0: //rotational
      motor[Q1] = b * scale(x2); motor[Q2] = b * scale(x2);
      motor[Q3] = b * scale(x2); motor[Q4] = b * scale(x2);
	}
}

task main() {
	while (true) {
		getJoystickSettings(joystick);
		x1 = joystick.joy1_x1;
		y1 = joystick.joy1_y1;
		x2 = joystick.joy1_x2;

		//RIP energy conservation

		//linear
		do { //prevents robot from attempting to move and rotate simultaneously
			if (abs(x1) <= nullRad) {x1 = 0;} //checks x1 inactive
			if (abs(y1) <= nullRad) {y1 = 0;} //checks y1 inactive
			if (x1 == 0 && y1 == 0) { //if left joystick inactive, sets the stage for right joystick
				preventsConflict = false;
				break;
			}
			if (x1 > 0) {move('e');}
			if (x1 < 0) {move('w');}
			if (y1 > 0) {move('n');}
			if (y1 < 0) {move('s');}
		} while (preventsConflict); //end linear

		//rotation
		do { //makes sure robot isn't already moving
			if (abs(x2) <= nullRad) { //checks if right joystick inactive
				preventsConflict = true; //sets the stage for left joystick to control
				break;
			}
			else if (x2 > nullRad) {move('a');}
			else if (x2 < -nullRad) {move('z');}
		} while (!preventsConflict); //end rotation
	}
}
